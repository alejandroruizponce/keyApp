// Generated by Apple Swift version 4.1 (swiftlang-902.0.48 clang-902.0.37.1)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR __attribute__((enum_extensibility(open)))
# else
#  define SWIFT_ENUM_ATTR
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if __has_feature(modules)
@import ObjectiveC;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="AKBLEKit",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


/// The <code>AKBLEManager</code> class provides a programming interface to the Activa Key BLE functions.
/// This class is responsible for the storage and management of keys, and the execution of key operations
/// using Bluetooth LE.
/// You do not create AKBLEManager objects directly, instead, you use the <code>shared()</code> method to access the singleton
/// instance for this class.
/// Because most of the methods in this class are asynchronous, you will need to supply a callback to most of the methods of this Framework.
/// The callback can be called several times, providing information about the process.
/// In case of an error, the callback will also be called to inform about the condition that prevented the operation from completion.
/// This class acts as a keychain.
/// To register a new key, you must supply a URL to a .oak2 file describing the key using the <code>addKey</code> method.
/// After the file is parsed and the key is added to the internal keychain, all the observers will receive a notification <code>keyAdded</code> with the
/// UUID used to refer to the key in the keychain. This UUID must be stored by the app using this framework because it is needed to activate
/// the key operation.
/// The Bluetooth manager is only activated when necessary. If you need to check the BT state, you will need to implement the AKBLEManagerDelegate protocol in one of your View Controllers.
/// You supply your delegate using the method <code>setBLEStatusDelegate()</code>.
SWIFT_CLASS("_TtC8AKBLEKit12AKBLEManager")
@interface AKBLEManager : NSObject
/// Este método es privado para que los programadores que usen este Framework se vean obligados a usar la instancia singleton obtenida a través del método <code>shared()</code>.
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end





@class AKBLEResult;
@protocol AKBLEManagerDelegate;

@interface AKBLEManager (SWIFT_EXTENSION(AKBLEKit))
/// Returns the shared AKBLEManager object.
+ (AKBLEManager * _Null_unspecified)shared SWIFT_WARN_UNUSED_RESULT;
/// Reads a new key operation from a URL. The URL must point to an <code>.oak2</code> file corresponding to the lock we will try to control using the mobile device. This method will generate a <code>UUID</code> identifier that will allow to reference the key in the internal keychain.
/// The possible result codes returned in the callback, its meaning, and the additional info returned in the payload, are:
/// \code
/// [0x0000]: Operation successful.
/// 	payload["uuid"] = UUID assigned to the new key added to the keychain.
/// [0x8000]: Cocoa error.
/// 	payload["error"] = Error object returned by the Cocoa error handling routines.
/// [0x8002]: Unknown File Format.
/// 	payload = nil
/// [0x8003]: There was some unidentified error with the keychain file. The key was not stored on the keychain.
/// 	payload = nil
/// [0x8004]: A key file with the same Instalator and Instalation codes already exists in the keychain.
/// 	payload["uuid"] = UUID of the existing key (you can delete that UUID before attempting to add the same key again, for example).
///
///
/// \endcode\param fromUrl The <code>URL</code> pointing to the file with the key data.
///
/// \param callback A callback function to be called after the Key is added to the internal keychain (if sucessful) or in the presence of an error that prevents the addition of the Key to the keychain.
///
- (void)addKeyFromUrl:(NSURL * _Nonnull)url callback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
/// Deletes a key from the internal keychain.
/// The possible result codes returned in the callback, its meaning, and the additional info returned in the payload, are:
/// \code
/// [0x0000]: operation successful.
/// 	payload["uuid"] = UUID of the key removed from the keychain. Identical to keyIdentifier
/// [0x8003]: Error in the internal keychain file
/// 	payload["uuid"] = UUID of the key that the system tried to delete. Identical to keyIdentifier
///
/// \endcode\param keyIdentifier The <code>UUID</code> to delete.
///
/// \param callback A callback function to be called after the Key is deleted from the internal keychain (if sucessful) or in the presence of an error that prevents the deletion of the Key from the keychain.
///
- (void)deleteKey:(NSString * _Nonnull)keyIdentifier callback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
/// Sets an object that will be notified of changes in the status of Bluetooth.
/// \param delegate The object that will be notified of changes in Bluetooth status.
///
- (void)setBLEStatusDelegate:(id <AKBLEManagerDelegate> _Nonnull)delegate;
/// Sends the operation contained inside a key to a nearby lock using Bluetooth LE.
/// The possible result codes returned in the callback, its meaning, and the additional info returned in the payload, are:
/// \code
/// [0x0000]: operation successful.
/// 	payload["uuid"] = UUID of the key whose operation was requested. Identical to keyIdentifier
/// [0x8001]: Key not found
/// 	payload["uuid"] = UUID of the key whose operation was requested. Can be nil.
/// [0x8003]: Error in the internal keychain file
/// 	payload["uuid"] = UUID of the key whose operation was requested.
/// [0x9001]: Time-out in the communication between the device and the lock
/// 	payload["uuid"] = UUID of the key whose operation time out.
/// [0x9002]: The operation was canceled by the user
/// 	payload["uuid"] = UUID of the key whose operation was canceled.
/// [0x9003]: A keycode is mandatory for this operation. You should ask the user for this numeric code (PIN) and supply it using the method `setClientCode` before retrying this method.
/// 	payload["uuid"] = UUID of the key whose operation was requested.
///
/// \endcodeIn a common scenario, you will call this method with a clientCode value of <code>nil</code>. If the key needs a PIN code, the key operation will not be executed and the callback function will be called with a return code <code>0x9003</code>. After you ask the user for a PIN code, you call again this method with the code supplied by the user.
/// \param keyIdentifier The <code>UUID</code> of the key whose data must be sent to the lock.
///
/// \param clientCode A client code is needed by some key operations. Valid codes are numeric codes.
///
/// \param callback A callback function to be called after the communication is successful, or in the presence of an error that prevents the correct transfer of data between the device and the lock.
///
- (void)activateOperationForKey:(NSString * _Nullable)keyIdentifier clientCode:(NSString * _Nullable)clientCode callback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
/// Stops the current operation for the supplied key UUID.
/// If the operation has already started, it cannot be stopped using this method.
/// \param keyIdentifier The <code>UUID</code> of the key whose operations must be stopped.
///
- (void)deactivateOperationForKey:(NSString * _Nonnull)keyIdentifier;
/// Returns a dictionary with the data registered for a Key.
/// The payload variable in <code>AKBLEResult</code> will contain a dictionary with the data registered for the key.
/// Valid keys and return values for the dictionary are (see <a href="http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns">Unicode Technical Standard #35</a> for date formats):
/// \code
/// 	'uuid':			-> String, key identifier
/// 	'version'		-> Int
/// 	'version1'		-> Int
/// 	'version2'		-> Int
/// 	'version3'		-> Int, these four numbers identify the version of the key
/// 	'title'			-> String, UTF8 encoding
/// 	'description'	-> String, UTF8 encoding
/// 	'extra'			-> Data, additional information from the management application
/// 	'dateVal'		-> String, UTF8 encoding and format `yyMMddHHmm`, check-in
/// 	'dateCad'		-> String, UTF8 encoding and format `yyMMddHHmm`, check-out
/// 	'codEmp1'		-> Int, Integrator code
/// 	'codEmp2'		-> Int, Installation code
/// 	'keycodeLon'	-> Int, PIN code length, if it is >0 the API is expecting a numeric code (using `setClientCode` for this key.
/// 	'conmTime'		-> Int, Time, in seconds, that bluetooth is trying to pair with the lock. Can be used to show some kind of time-out countdown.
///
/// \endcode\param keyIdentifier The <code>UUID</code> to read.
///
/// \param callback A callback function to be called after the Key is added to the internal keychain (if sucessful) or in the presence of an error that prevents the addition of the Key to the keychain.
///
- (void)getInfoForKey:(NSString * _Nonnull)keyIdentifier callback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
/// Returns an array with all the UUIDs for keys registered with this device. This array is returned in the payload variable of the AKBLEResult, accesible under a <code>uuids</code> key.
/// \param callback A callback function to be called after the Key is added to the internal keychain (if sucessful) or in the presence of an error that prevents the addition of the Key to the keychain.
///
- (void)getKeyUUIDsWithCallback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
/// Returns the data registered for all Keys in the internal keychain.
/// The possible result codes returned in the callback, its meaning, and the additional info returned in the payload, are:
/// \code
/// [0x0000]: operation successful.
/// 	payload = nil if there are no keys in the keychain.
/// 	payload["keys"] = Array with info about all keys. See following description for more information.
///
/// \endcodeThe payload variable in <code>AKBLEResult</code> will return an array. Each element in the array is a dictionary [String: Any?] with the data registered for one key. Any key in this dictionary can be absent.
/// Valid keys and return values for the dictionary are (see <a href="http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns">Unicode Technical Standard #35</a> for date formats):
/// \code
/// 	'uuid':			-> String, key identifier
/// 	'version'		-> Int
/// 	'version1'		-> Int
/// 	'version2'		-> Int
/// 	'version3'		-> Int, these four numbers identify the version of the key
/// 	'title'			-> String, UTF8 encoding
/// 	'description'	-> String, UTF8 encoding
/// 	'extra'			-> Data, additional information from the management application
/// 	'dateVal'		-> String, UTF8 encoding and format `yyMMddHHmm`, check-in
/// 	'dateCad'		-> String, UTF8 encoding and format `yyMMddHHmm`, check-out
/// 	'codEmp1'		-> Int, Integrator code
/// 	'codEmp2'		-> Int, Installation code
/// 	'keycodeLon'	-> Int, PIN code length, if it is >0 the API is expecting a numeric code (using `setClientCode` for this key.
/// 	'conmTime'		-> Int, Time, in seconds, that bluetooth is trying to pair with the lock. Can be used to show some kind of time-out countdown.
///
/// \endcode\param keyIdentifier The <code>UUID</code> to read.
///
/// \param callback A callback function to be called after the Key is added to the internal keychain (if sucessful) or in the presence of an error that prevents the addition of the Key to the keychain.
///
- (void)getKeysInfoWithCallback:(void (^ _Nonnull)(AKBLEResult * _Nonnull))handler;
@end


/// Protocol to be implemented by a class that needs to be informed about changes in Bluetooth states.
SWIFT_PROTOCOL("_TtP8AKBLEKit20AKBLEManagerDelegate_")
@protocol AKBLEManagerDelegate
/// This method will be called on the delegate whenever the Bluetooth state changes.
/// Values for the Bluetooth state (and corresponding CBManagerState enum values):
/// \code
/// 	[0x00]: unknown
/// 	[0x01]: resetting
/// 	[0x02]: unsupported
/// 	[0x03]: unauthorized
/// 	[0x04]: poweredOff
/// 	[0x05]: poweredOn
///
/// \endcode\param new The value of this param determines the new state:
///
- (void)didChangeBLEStatusWithNew:(NSInteger)new_;
@end


/// All callbacks to the AKBLEManager singleton instance methods can return an instance of this struct.
/// Possible codes and its meaning are:
/// \code
/// [0x0000]: Operation successful
/// [0x8000]: Error in the Cocoa domain
/// [0x8001]: Key not registered in the keychain
/// [0x8002]: The file with the key information has the wrong format
/// [0x8003]: Error in the keychain file
/// [0x8004]: A key with the same origin already exists in the keychain
/// [0x9000]: Error in the communication between the device and the lock
/// [0x9001]: Timeout in the communication between the device and the lock
/// [0x9002]: The operation was canceled by the user
/// [0x9003]: A keycode is mandatory for this operation
/// [0xffff]: Unknown Error
///
/// [    -1]: Timer tick
///
/// \endcode
SWIFT_CLASS("_TtC8AKBLEKit11AKBLEResult")
@interface AKBLEResult : NSObject
/// Numeric code of the result.
/// <ul>
///   <li>
///     Possitive numbers identify errors.
///   </li>
///   <li>
///     Negative numbers identify information results.
///   </li>
///   <li>
///     Zero means that the operation was successful.
///   </li>
/// </ul>
@property (nonatomic, readonly) NSInteger code;
/// Textual description of the result, for use by the programmers.
/// Not intended for showing to the user.
@property (nonatomic, readonly, copy) NSString * _Nonnull internalDescription;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull objc_payload;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
